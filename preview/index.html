<!doctype html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parabula — Reader</title>

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500&display=swap" rel="stylesheet" />

    <link rel="stylesheet" href="/styles/a4-base.css" />
    <link rel="stylesheet" href="/styles/preview.css" />
  </head>
  <body>
    <div class="reader-shell">
      <header class="reader-topbar">
        <div class="reader-topbarRow">
          <div class="reader-title" id="readerTitle">תצוגה מקדימה — כל הדפים</div>

          <div class="reader-controls">
            <div class="reader-modes" role="group" aria-label="מצב תצוגה">
              <button class="reader-btn" id="modeAllBtn" type="button">כל הדפים</button>
              <button class="reader-btn" id="modeBookBtn" type="button">דפדוף</button>
            </div>

            <button class="reader-btn reader-navBtn" id="prevBtn" type="button">◀ הקודם</button>
            <select class="reader-select" id="fileSelect" aria-label="בחירת מסמך"></select>
            <button class="reader-btn reader-navBtn" id="nextBtn" type="button">הבא ▶</button>
          </div>

          <div class="reader-meta" id="meta"></div>
        </div>

        <nav class="reader-topics" id="topicButtons" aria-label="מעבר בין נושאים"></nav>
      </header>

      <main class="reader-main">
        <aside class="reader-sidebar" aria-label="תוכן עניינים">
          <div class="reader-sidebar-title">תוכן עניינים</div>
          <div class="reader-list" id="fileList"></div>
        </aside>

        <section class="reader-stage" aria-label="תצוגה">
          <div class="reader-fallback" id="readerFallback" role="status">
            טוען…
          </div>
          <div class="reader-frameWrap" id="frameWrap">
            <div class="reader-book" id="book" aria-label="ספר" hidden>
              <div class="reader-leaf reader-leaf--right" aria-label="עמוד ימין">
                <iframe class="reader-frame" id="frameRight" title="תצוגה מקדימה — ימין" referrerpolicy="no-referrer"></iframe>
              </div>

              <div class="reader-gutter" aria-hidden="true"></div>

              <div class="reader-leaf reader-leaf--left" aria-label="עמוד שמאל">
                <iframe class="reader-frame" id="frameLeft" title="תצוגה מקדימה — שמאל" referrerpolicy="no-referrer"></iframe>
                <div class="reader-empty" id="emptyLeft" hidden>סוף</div>
              </div>
            </div>

            <div class="reader-all" id="allPages" aria-label="כל הדפים"></div>
          </div>
        </section>
      </main>
    </div>

    <script type="module">
      const fileSelect = document.getElementById('fileSelect');
      const fileList = document.getElementById('fileList');
      const frameRight = document.getElementById('frameRight');
      const frameLeft = document.getElementById('frameLeft');
      const emptyLeft = document.getElementById('emptyLeft');
      const meta = document.getElementById('meta');
      const prevBtn = document.getElementById('prevBtn');
      const nextBtn = document.getElementById('nextBtn');
      const frameWrap = document.getElementById('frameWrap');
      const readerTitle = document.getElementById('readerTitle');
      const modeAllBtn = document.getElementById('modeAllBtn');
      const modeBookBtn = document.getElementById('modeBookBtn');
      const book = document.getElementById('book');
      const allPages = document.getElementById('allPages');
      const topicButtons = document.getElementById('topicButtons');
      const readerFallback = document.getElementById('readerFallback');

      /** @type {{topics: {name: string, pages: any[]}[], flat: any[]}} */
      let toc = { topics: [], flat: [] };

      /** @type {Map<string, HTMLIFrameElement>} */
      let allFrames = new Map();

      /** @type {Map<string, HTMLElement>} */
      let allItems = new Map();

      /** @type {IntersectionObserver | null} */
      let allIo = null;

      /** @type {Set<HTMLIFrameElement>} */
      let allLoaded = new Set();

      let currentMode = 'all';

      /** @type {Map<string, HTMLButtonElement>} */
      let topicButtonsMap = new Map();

      function showFallback(message, details = '') {
        if (!readerFallback) return;
        const text = [message, details].filter(Boolean).join('\n');
        readerFallback.textContent = text;
        readerFallback.hidden = false;
      }

      function hideFallback() {
        if (!readerFallback) return;
        readerFallback.hidden = true;
      }

      // If the environment blocks module scripts, fetch, or iframes (can happen in VS Code Simple Browser),
      // we still want a visible message rather than a blank screen.
      window.addEventListener('error', (e) => {
        showFallback('שגיאה בתצוגה המקדימה.', String(e?.message || ''));
      });
      window.addEventListener('unhandledrejection', (e) => {
        const reason = e?.reason instanceof Error ? e.reason.message : String(e?.reason || '');
        showFallback('שגיאה בתצוגה המקדימה.', reason);
      });

      function getMode() {
        const url = new URL(window.location.href);
        const mode = (url.searchParams.get('mode') || '').toLowerCase();
        return mode === 'book' ? 'book' : 'all';
      }

      function setMode(mode) {
        const url = new URL(window.location.href);
        url.searchParams.set('mode', mode);
        window.history.replaceState({}, '', url);
      }

      function getSelectedFile() {
        const url = new URL(window.location.href);
        return url.searchParams.get('file') || '';
      }

      function setSelectedFile(file) {
        const url = new URL(window.location.href);
        url.searchParams.set('file', file);
        window.history.replaceState({}, '', url);

        try {
          window.localStorage.setItem('reader:lastFile', file);
        } catch {
          // ignore
        }
      }

      function findEntry(file) {
        return toc.flat.find((p) => p.file === file) || null;
      }

      function labelForEntry(entry) {
        if (!entry) return '';
        if (entry.topic && typeof entry.pageIndex === 'number' && typeof entry.pageTotal === 'number') {
          return `${entry.topic} — עמוד ${entry.pageIndex} / ${entry.pageTotal}`;
        }
        return entry.title || entry.file;
      }

      function findIndex(file) {
        return toc.flat.findIndex((p) => p.file === file);
      }

      function spreadStartIndexForFile(file) {
        const idx = findIndex(file);
        if (idx < 0) return 0;
        // Book-like spread: odd pages on the right (1-based), even on the left.
        return idx % 2 === 0 ? idx : Math.max(0, idx - 1);
      }

      function spreadFiles(startIdx) {
        const right = toc.flat[startIdx] || null;
        const left = toc.flat[startIdx + 1] || null;
        return { right, left };
      }

      function describeSpread(right, left) {
        if (!right) return '';
        if (right.topic && left && left.topic && right.topic === left.topic) {
          const a = typeof right.pageIndex === 'number' ? right.pageIndex : null;
          const b = typeof left.pageIndex === 'number' ? left.pageIndex : null;
          const total = typeof right.pageTotal === 'number' ? right.pageTotal : null;
          if (a && b && total) return `${right.topic} — עמודים ${a}–${b} / ${total}`;
        }

        const r = labelForEntry(right);
        const l = left ? labelForEntry(left) : '';
        return l ? `${r} | ${l}` : r;
      }

      function updateSpread(startIdx, reason) {
        const { right, left } = spreadFiles(startIdx);
        if (!right) return;

        const bust = String(Date.now());
        frameRight.src = `/${encodeURIComponent(right.file)}?v=${bust}`;

        if (left) {
          emptyLeft.hidden = true;
          frameLeft.hidden = false;
          frameLeft.src = `/${encodeURIComponent(left.file)}?v=${bust}`;
        } else {
          frameLeft.src = 'about:blank';
          frameLeft.hidden = true;
          emptyLeft.hidden = false;
        }

        meta.textContent = `${describeSpread(right, left)}${reason ? ' • ' + reason : ''}`;
      }

      function maybeWarnIframeBlocked(frameEl) {
        // After load, we expect to have an accessible document with an .a4-page.
        // If not, show a helpful fallback including a direct page link.
        try {
          const doc = frameEl.contentDocument;
          const hasPage = !!doc?.querySelector?.('.a4-page');
          if (hasPage) return;
        } catch {
          // ignore
        }

        const selected = getSelectedFile();
        const direct = selected ? `/${encodeURIComponent(selected)}` : '/';
        showFallback(
          'נראה שהחלון הפנימי חוסם הצגת מסמכים בתוך iframe.',
          `פתח את העמוד ישירות: ${direct}`
        );
      }

      function injectReaderStyles(doc) {
        if (!doc) return;
        const existing = doc.getElementById('__reader_injected');
        if (existing) return;

        const style = doc.createElement('style');
        style.id = '__reader_injected';
        style.textContent = `
          .preview-nav { display: none !important; }
          html, body { background: var(--bg-paper) !important; display: block !important; }
          body { margin: 0 !important; padding: 0 !important; overflow: hidden !important; }
          .a4-page { margin: 0 !important; margin-bottom: 0 !important; box-shadow: none !important; }
        `;
        doc.head.appendChild(style);
      }

      function fitA4InFrame(frameEl, mode = 'book') {
        try {
          const doc = frameEl.contentDocument;
          if (!doc) return;
          injectReaderStyles(doc);

          const page = doc.querySelector('.a4-page');
          if (!page) return;

          // Reset any previous scaling.
          page.style.zoom = '';
          page.style.transform = '';
          page.style.transformOrigin = '';

          const pageRect = page.getBoundingClientRect();
          const availW = frameEl.clientWidth;
          const availH = frameEl.clientHeight;
          if (availW <= 0 || availH <= 0 || pageRect.width <= 0 || pageRect.height <= 0) return;

          // Allow upscaling in preview so the page can actually fill the available space.
          // Cap to avoid absurd zoom on very large viewports.
          const maxScale = 2.5;
          const scaleRaw =
            mode === 'all'
              ? availW / pageRect.width
              : Math.min(availW / pageRect.width, availH / pageRect.height);
          const scale = Math.min(scaleRaw, maxScale);

          // Prefer `zoom` (stable in Chromium) to avoid transform layout issues.
          page.style.zoom = String(scale);

          if (mode === 'all') {
            const desiredH = Math.ceil(pageRect.height * scale + 2);
            if (Number.isFinite(desiredH) && desiredH > 0) frameEl.style.height = `${desiredH}px`;
          }
        } catch {
          // Ignore cross-origin / transient iframe loading states.
        }
      }

      function setModeUi(mode) {
        currentMode = mode;
        const isAll = mode === 'all';

        document.body.dataset.mode = mode;

        book.hidden = isAll;
        allPages.hidden = !isAll;

        // Keep navigation buttons always visible.
        prevBtn.hidden = false;
        nextBtn.hidden = false;

        modeAllBtn.classList.toggle('is-active', isAll);
        modeBookBtn.classList.toggle('is-active', !isAll);

        if (readerTitle) readerTitle.textContent = isAll ? 'תצוגה מקדימה — כל הדפים' : 'תצוגה מקדימה — דפדוף';
      }

      function updatePrevNextDisabled() {
        const current = getSelectedFile();
        if (!current || toc.flat.length === 0) {
          prevBtn.disabled = true;
          nextBtn.disabled = true;
          return;
        }

        if (currentMode === 'all') {
          const idx = findIndex(current);
          prevBtn.disabled = idx <= 0;
          nextBtn.disabled = idx < 0 || idx >= toc.flat.length - 1;
          return;
        }

        const startIdx = spreadStartIndexForFile(current);
        let maxStart = Math.max(0, toc.flat.length - 1);
        if (maxStart % 2 === 1) maxStart -= 1;
        prevBtn.disabled = startIdx <= 0;
        nextBtn.disabled = startIdx >= maxStart;
      }

      function selectNeighbor(delta) {
        const current = getSelectedFile();
        if (!current) return;

        if (currentMode === 'all') {
          const idx = findIndex(current);
          if (idx < 0) return;
          const nextFile = toc.flat[idx + delta]?.file || '';
          if (!nextFile) return;
          openFileInCurrentMode(nextFile, 'ניווט');
          setActiveTopicButtons(nextFile);
          return;
        }

        selectNeighborSpread(delta);
      }

      function updateMetaAll(selectedFile, reason) {
        const entry = findEntry(selectedFile);
        const label = entry ? labelForEntry(entry) : selectedFile || '';
        const base = `כל הדפים — ${toc.flat.length} דפים`;
        const tail = label ? ` • ${label}` : '';
        meta.textContent = `${base}${tail}${reason ? ' • ' + reason : ''}`;
      }

      function setActiveTopicButtons(selectedFile) {
        const entry = findEntry(selectedFile);
        const activeTopic = entry ? entry.topic || 'אחר' : '';
        for (const [topicName, btn] of topicButtonsMap.entries()) {
          btn.classList.toggle('is-active', topicName === activeTopic);
          if (topicName === activeTopic) btn.setAttribute('aria-current', 'true');
          else btn.removeAttribute('aria-current');
        }
      }

      function openFileInCurrentMode(file, reason) {
        if (!file) return;
        if (currentMode === 'all') {
          setSelectedFile(file);
          fileSelect.value = file;
          renderList(file);
          highlightAllSelected(file);
          loadAllFrame(file);
          scrollToAllSelected(file);
          updateMetaAll(file, reason);
        } else {
          const idx = spreadStartIndexForFile(file);
          const r = toc.flat[idx]?.file || file;
          setSelectedFile(r);
          fileSelect.value = r;
          renderList(r);
          updateSpread(idx, reason);
        }
      }

      function buildTopicButtons() {
        if (!topicButtons) return;
        topicButtons.innerHTML = '';
        topicButtonsMap = new Map();

        for (const topic of toc.topics) {
          const firstPage = topic?.pages?.[0]?.file || '';
          const name = topic?.name || '';
          if (name === 'אחר') continue;
          if (!name || !firstPage) continue;

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'reader-btn reader-topicBtn';
          btn.textContent = name;
          btn.addEventListener('click', () => {
            openFileInCurrentMode(firstPage, 'נושא');
            setActiveTopicButtons(getSelectedFile() || firstPage);
          });

          topicButtons.appendChild(btn);
          topicButtonsMap.set(name, btn);
        }
      }

      function ensureAllIo() {
        if (allIo) return;
        if (!('IntersectionObserver' in window)) return;

        allIo = new IntersectionObserver(
          (entries) => {
            for (const e of entries) {
              if (!e.isIntersecting) continue;
              const item = e.target;
              const file = item?.dataset?.file;
              if (!file) continue;
              const frame = allFrames.get(file);
              if (!frame) continue;
              loadAllFrame(file);
            }
          },
          // In "all pages" mode we use normal browser scrolling, so observe relative to viewport.
          { root: null, rootMargin: '800px 0px' }
        );
      }

      function loadAllFrame(file) {
        const frame = allFrames.get(file);
        if (!frame) return;
        if (allLoaded.has(frame)) return;

        const srcBase = frame.dataset.src;
        if (!srcBase) return;

        const bust = String(Date.now());
        frame.src = `${srcBase}?v=${bust}`;
        allLoaded.add(frame);

        frame.addEventListener(
          'load',
          () => {
            fitA4InFrame(frame, 'all');
            maybeWarnIframeBlocked(frame);
          },
          { once: true }
        );
      }

      function highlightAllSelected(selectedFile) {
        for (const [file, el] of allItems.entries()) {
          el.classList.toggle('is-active', file === selectedFile);
        }
      }

      function scrollToAllSelected(selectedFile) {
        const item = allItems.get(selectedFile);
        if (!item) return;
        item.scrollIntoView({ block: 'start' });
      }

      function renderAllPages(selectedFile) {
        allPages.innerHTML = '';
        allFrames = new Map();
        allItems = new Map();
        allLoaded = new Set();

        if (allIo) {
          try {
            allIo.disconnect();
          } catch {
            // ignore
          }
          allIo = null;
        }

        const frag = document.createDocumentFragment();

        for (const entry of toc.flat) {
          const item = document.createElement('div');
          item.className = 'reader-allItem';
          item.dataset.file = entry.file;

          const frame = document.createElement('iframe');
          frame.className = 'reader-allFrame';
          frame.title = entry.title || entry.file;
          frame.referrerPolicy = 'no-referrer';
          frame.loading = 'lazy';
          frame.dataset.src = `/${encodeURIComponent(entry.file)}`;
          item.appendChild(frame);

          frag.appendChild(item);
          allFrames.set(entry.file, frame);
          allItems.set(entry.file, item);
        }

        allPages.appendChild(frag);
        ensureAllIo();

        hideFallback();

        if (allIo) {
          for (const item of allItems.values()) allIo.observe(item);
        } else {
          // Fallback: load first few eagerly.
          for (let i = 0; i < Math.min(6, toc.flat.length); i++) {
            const f = toc.flat[i]?.file;
            if (f) loadAllFrame(f);
          }
        }

        highlightAllSelected(selectedFile);
        loadAllFrame(selectedFile);
        scrollToAllSelected(selectedFile);
        updateMetaAll(selectedFile, 'מוכן');
      }

      function renderList(selectedFile) {
        fileSelect.innerHTML = '';
        fileList.innerHTML = '';

        let rightFile = '';
        let leftFile = '';

        if (currentMode === 'all') {
          rightFile = selectedFile || '';
          leftFile = '';
        } else {
          const startIdx = spreadStartIndexForFile(selectedFile);
          const { right, left } = spreadFiles(startIdx);
          rightFile = right?.file || '';
          leftFile = left?.file || '';
        }

        for (const entry of toc.flat) {
          const opt = document.createElement('option');
          opt.value = entry.file;
          opt.textContent = labelForEntry(entry);
          fileSelect.appendChild(opt);
        }

        for (const topic of toc.topics) {
          const section = document.createElement('section');
          section.className = 'reader-topic';

          const title = document.createElement('div');
          title.className = 'reader-topicTitle';
          title.textContent = topic.name;
          section.appendChild(title);

          const list = document.createElement('div');
          list.className = 'reader-topicList';

          for (const entry of topic.pages) {
            const btn = document.createElement('button');
            btn.type = 'button';
            const inSpread = entry.file === rightFile || entry.file === leftFile;
            btn.className =
              'reader-item' +
              (currentMode === 'all'
                ? entry.file === rightFile
                  ? ' is-active'
                  : ''
                : entry.file === rightFile
                  ? ' is-active'
                  : inSpread
                    ? ' is-inSpread'
                    : '');

            if (entry.topic && typeof entry.pageIndex === 'number' && typeof entry.pageTotal === 'number') {
              btn.textContent = `עמוד ${entry.pageIndex} / ${entry.pageTotal}`;
            } else {
              btn.textContent = entry.title || entry.file;
            }

            btn.addEventListener('click', () => {
              if (currentMode === 'all') {
                setSelectedFile(entry.file);
                fileSelect.value = entry.file;
                renderList(entry.file);
                highlightAllSelected(entry.file);
                loadAllFrame(entry.file);
                scrollToAllSelected(entry.file);
                updateMetaAll(entry.file, 'נפתח');
              } else {
                const idx = spreadStartIndexForFile(entry.file);
                const r = toc.flat[idx]?.file || '';
                setSelectedFile(r);
                fileSelect.value = r;
                renderList(r);
                updateSpread(idx, 'נפתח');
              }
            });
            list.appendChild(btn);
          }

          section.appendChild(list);
          fileList.appendChild(section);
        }

        fileSelect.value = rightFile;
        setActiveTopicButtons(rightFile);
        updatePrevNextDisabled();
      }

      function selectNeighborSpread(deltaSpreads) {
        if (currentMode === 'all') return;
        const current = getSelectedFile();
        const startIdx = spreadStartIndexForFile(current);
        let maxStart = Math.max(0, toc.flat.length - 1);
        // Spread starts are even indices: 0,2,4,... (so right page is odd-numbered 1-based).
        if (maxStart % 2 === 1) maxStart -= 1;

        const nextStart = Math.min(maxStart, Math.max(0, startIdx + deltaSpreads * 2));
        const rightFile = toc.flat[nextStart]?.file;
        if (!rightFile) return;
        setSelectedFile(rightFile);
        renderList(rightFile);
        updateSpread(nextStart, 'דפדוף');
      }

      async function boot() {
        showFallback('טוען…');

        try {
          const res = await fetch('/api/toc', { cache: 'no-store' });
          if (!res.ok) throw new Error(`TOC HTTP ${res.status}`);

          const data = await res.json();
          toc = {
            topics: Array.isArray(data.topics) ? data.topics : [],
            flat: Array.isArray(data.flat) ? data.flat : []
          };

          const preferred = getSelectedFile();

          let last = '';
          try {
            last = window.localStorage.getItem('reader:lastFile') || '';
          } catch {
            // ignore
          }

          const exists = (f) => toc.flat.some((p) => p.file === f);
          const initial = exists(preferred) ? preferred : exists(last) ? last : toc.flat[0]?.file || '';

          if (!initial) {
            showFallback('לא נמצאו קבצי HTML להצגה.');
            return;
          }

        const mode = getMode();
        setModeUi(mode);
        buildTopicButtons();

        if (mode === 'all') {
          // keep exact selected file for scrolling/highlight
          setMode('all');
          setSelectedFile(initial);
          renderList(initial);
          renderAllPages(initial);
          setActiveTopicButtons(initial);
        } else {
          setMode('book');
          const startIdx = spreadStartIndexForFile(initial);
          const rightFile = toc.flat[startIdx]?.file || initial;
          setSelectedFile(rightFile);
          renderList(rightFile);
          updateSpread(startIdx, 'מוכן');
          setActiveTopicButtons(rightFile);
        }

        hideFallback();

        modeAllBtn.addEventListener('click', () => {
          if (currentMode === 'all') return;
          setMode('all');
          setModeUi('all');
          const f = getSelectedFile() || toc.flat[0]?.file || '';
          if (!f) return;
          setSelectedFile(f);
          renderList(f);
          renderAllPages(f);
        });

        modeBookBtn.addEventListener('click', () => {
          if (currentMode === 'book') return;
          setMode('book');
          setModeUi('book');
          const f = getSelectedFile() || toc.flat[0]?.file || '';
          if (!f) return;
          const startIdx = spreadStartIndexForFile(f);
          const rightFile = toc.flat[startIdx]?.file || f;
          setSelectedFile(rightFile);
          renderList(rightFile);
          updateSpread(startIdx, 'נפתח');
        });

        fileSelect.addEventListener('change', () => {
          const f = fileSelect.value;
          openFileInCurrentMode(f, 'נבחר');
          setActiveTopicButtons(getSelectedFile() || f);
        });

        prevBtn.addEventListener('click', () => selectNeighbor(-1));
        nextBtn.addEventListener('click', () => selectNeighbor(1));

        window.addEventListener('keydown', (e) => {
          const tag = e.target?.tagName;
          if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
          // RTL-friendly: Left = forward, Right = back
          if (e.key === 'ArrowLeft' || e.key === 'PageDown') selectNeighbor(1);
          if (e.key === 'ArrowRight' || e.key === 'PageUp') selectNeighbor(-1);
        });

        const es = new EventSource('/events');
        es.addEventListener('reload', () => {
          const currentFile = getSelectedFile();
          if (currentMode === 'all') {
            // Reload only already-loaded frames.
            const bust = String(Date.now());
            for (const frame of allLoaded) {
              const srcBase = frame.dataset.src;
              if (!srcBase) continue;
              frame.src = `${srcBase}?v=${bust}`;
            }
            if (currentFile) updateMetaAll(currentFile, 'עודכן');
            return;
          }

          if (!currentFile) return;
          const start = spreadStartIndexForFile(currentFile);
          updateSpread(start, 'עודכן');
        });

        function scheduleFit() {
          // Give MathJax/layout a beat to settle before fitting.
          setTimeout(() => fitA4InFrame(frameRight, 'book'), 80);
          setTimeout(() => fitA4InFrame(frameRight, 'book'), 250);
          if (!frameLeft.hidden) {
            setTimeout(() => fitA4InFrame(frameLeft, 'book'), 80);
            setTimeout(() => fitA4InFrame(frameLeft, 'book'), 250);
          }
        }

        frameRight.addEventListener('load', scheduleFit);
        frameLeft.addEventListener('load', scheduleFit);

        frameRight.addEventListener('load', () => maybeWarnIframeBlocked(frameRight));
        frameLeft.addEventListener('load', () => maybeWarnIframeBlocked(frameLeft));

        if (window.ResizeObserver && frameWrap) {
          const ro = new ResizeObserver(() => {
            if (currentMode === 'all') {
              for (const frame of allLoaded) fitA4InFrame(frame, 'all');
              return;
            }

            fitA4InFrame(frameRight, 'book');
            if (!frameLeft.hidden) fitA4InFrame(frameLeft, 'book');
          });
          ro.observe(frameWrap);
        } else {
          window.addEventListener('resize', () => {
            if (currentMode === 'all') {
              for (const frame of allLoaded) fitA4InFrame(frame, 'all');
              return;
            }

            fitA4InFrame(frameRight, 'book');
            if (!frameLeft.hidden) fitA4InFrame(frameLeft, 'book');
          });
        }
        } catch (err) {
          const message = err instanceof Error ? err.message : String(err);
          showFallback('לא ניתן לטעון את התצוגה המקדימה.', message);
        }
      }

      boot();
    </script>
  </body>
</html>
